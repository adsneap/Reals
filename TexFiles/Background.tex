\documentclass[ProjectReport]{subfiles}


\begin{document}

\section{Background}

\subsection{Personal Background}

I am a fourth year student undertaking a 40 credit MSci project. I also completed a 40 credit project in my third year, as required for my joint Mathematics and Computer Science degree: \url{https://adsneap.github.io/CSProject}. In my third year project, I learned how to implement mathematical proofs in Agda. The secondary goal, which was not achieved due to time constraints, was to show that the Dedekind reals are a Dedekind-complete Archimedean ordered field. I defined the Dedekind reals, by first constructing the integers and rationals.

The two projects are built on top of Escardo's Type Topology library \cite{TypeTopology}. I love working in the intersection of computer science and mathematics, and so formalising mathematics using type theory as the framework is very appealing to me, and the main reason I chose to continue working in this area.

\subsection{Agda}

This library is written in the dependently type programming language Agda. Similarly to Coq and Lean, Agda may be used as a proof assistant. At it's core, Agda is a functional programming language, and shares many similarities with Haskell. Like Haskell, Agda is strongly typed, but differs from Haskell in that it allows for dependent types. Consequently, Agda is a suitable language for proving mathematical theorems. 

Mathematical statements are represented by types, and functions which produce an output of a type are seen as proofs of this type. Dependent types give us the flexibility to express properties of programs \cite{AgdaDependentTypes}. Strong typing means that there is no room for ambiguity. It is enforced that every term has a type, so there is no scope for problematic calls to functions with inputs of inappropriate types. These two properties of Agda together are powerful. We can ensure that a program developed in Agda conforms to a specification by imposing the specification within the type of the program.

To give an explicit example, we can write the specification that a list is sorted. In Haskell, you can write a function which sorts a list, but in Agda we can go further and \textit{prove} that the function sorts the list. This extends to mathematical statements. We can write the statement ``there exists a natural number between 70 and 100, which is divisible by 24" as a type, and a proof of this statement gives an algorithm for finding such a number which is guaranteed to be correct.

In this project, I am building on top of my supervisor's Type Topology library, which is a library of ``various new theorems in univalent mathematics written in Agda" \cite{TypeTopology}. The library is deliberately minimal and assumes as little as possible for each proof, using ``principles of HoTT/UF, \ldots and classical mathematics as explicit assumptions for the theorems \ldots that require them". This library provides me with the mathematical language in which I write my proofs. I write proofs in Agda, in MLTT, and by the Curry-Howard correspondence we have the mathematical interpretation of the proofs.  The next section serves as an brief introduction to the types I use in my work, and their analogous object in mathematics, as described the mentioned correspondence.

\subsection{Mathematics in Type Theory}

In type theory, every object has a type. We declare types in the following way:

\TypeExample

The type \AgdaDatatype{ℤ} defines the integers. The integers live in the lowest universe, which in TypeTopology is denoted by U0 {TODO : ADD COMMAND FOR U0}. A universe is a type whose elements are also types. There are two constructors, \AgdaInductiveConstructor{pos} and \AgdaInductiveConstructor{negsucc} which are functions that allow us to construct Integers. For example, by applying the natural number \AgdaInductiveConstructor{zero} to the function \AgdaInductiveConstructor{pos}, we obtain the integer \AgdaInductiveConstructor{pos}\AgdaSpace\AgdaInductiveConstructor{zero} which has type \AgdaDatatype{ℤ}, denoted as
\AgdaInductiveConstructor{pos zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{ℤ}.

I will now introduce the types that correspond to the language of mathematics, described by the Curry-Howard correspondence. 

In type theory, a mathematical statement can be written as a type, or more explicitly propositions are types. Not all types are propositions, however, so it must be proven that a given type is a proposition. This amounts to proving that a proof of the type is unique. 

-- Unit
-- Empty
-- Sigma
-- Function Extensionality
-- Prop Ext
-- Prop Trunc

\begin{comment}
When building a library, certainly many of the initial proofs may be auto-solved by Agda, but in my experience asking Agda to look for a proof results in an indefinite hang due to the size of the terms I am working with. If Agda compiles the code, then I can sure that the proofs I am writing is correct up to the interpretation of the types I write, but I cannot rely on Agda to auto-generate proofs for me.
\end{comment}

\end{document}
